## 목차  
- 클래스 체계
  - 캡슐화
- 클래스는 작아야 한다!
	- 단일 책임 원칙
	- 응집도
	- 응집도를 유지하면 작은 클래스 여럿이 나온다
- 변경하기 쉬운 클래스
  - 변경으로부터 거리

-------------------------------------------------------------

> 지금까지는 코드와 함수 단계까지 깨끗한 코드를 만들기 위한 공부를 하였다.<br/>
이번 장에서는 더 높은 차원의 단계인 클래스를 깨끗하게 만드는 방법을 다룬다.
<br/>

# 클래스 체계
클래스를 정의하는 표준 자바 관례를 살펴보면 아래와 같다.

*변수 목록*<br/>
*정적 공개 상수 public static*<br/>
*정적 비공개 상수 private static*<br/>
*비공개 인스턴스 변수 private*<br/>
*공개 함수*<br/>
*비공개 함수*<br/>

관례를 따르면 추상화 단계가 순차적으로 내려가 신문처럼 읽을 수 있게 된다.  <br/>


> ### 캡슐화
변수와 유틸리티 함수는 가능한 공개하지 않는 편이 낫지만 반드시 숨겨야 하는 것은 아니다.<br/>
때로는 protected로 선언해 테스트 코드에 접근을 허용하기도 한다.<br/>
물론, 이전에 먼저 비공개 상태를 유지할 방법을 강구해야하고<br/>
캡슐화를 풀어주는것은 최후의 수단이다

# 클래스는 작아야 한다!
클래스를 만들 때 중요한 규칙은 첫째도 둘째도 크기이다.
이때 떠오르는 의문은 '얼마나 작아야 하는가?' 일 것이다.<br/>
함수의 경우 물리적인 행 수로 크기를 측정했지만<br/>
클래스는 다른 척도인 **책임**을 센다.

70개의 메서드를 가진 클래스
```java
public class SuperDashboard extends JFrame implements MetaDataUser {
    public String getCustomizerLanguagePath()
    public void setSystemConfigPath(String systemConfigPath) 
    public String getSystemConfigDocument()
    public void setSystemConfigDocument(String systemConfigDocument) 
    public boolean getGuruState()
    public boolean getNoviceState()
    public boolean getOpenSourceState()
    public void showObject(MetaObject object) 
    ...//의미없는 내용이 너무 길어 매서드 약 50개 생략    
    public void processDeleteObject(MetaObject object)
    public boolean getAttachedToDesigner()
    public void processProjectChangedState(boolean hasProjectChanged) 
    public void processObjectNameChanged(MetaObject object)
    public void runProject()
    public void setAçowDragging(boolean allowDragging) 
    public boolean allowDragging()
    public boolean isCustomizing()
    public void setTitle(String title)
    public IdeMenuBar getIdeMenuBar()
    public void showHelper(MetaObject metaObject, String propertyName) 
}
```
* 대다수의 개발자들은 위 클래스가 엄청나게 크다는 사실에 동의한다.     
       
5개의 메서드를 가진 클래스       
```java
public class SuperDashboard extends JFrame implements MetaDataUser {
    public Component getLastFocusedComponent()
    public void setLastFocused(Component lastFocused)
    public int getMajorVersionNumber()
    public int getMinorVersionNumber()
    public int getBuildNumber() 
}
```

다음과 같이 메서드가 5개인 클래스는 우리가 원하는 클래스일까?<br/>
메서드 수가 적음에도 책임이 너무 많기 때문에 아니다.

클래스 이름은 해당 클래스 책임을 기술해야 한다.<br/>
이름이 떠오르지 않는다면 클래스의 크기가 너무 커서 그럴것이고<br/>
이름이 모호하다면 책임이 너무 많아서 일 것이다.<br/>
또한 이름은 if,and,or.but 을 사용하지 않고 25단어 내외로 작성해야한다.<br/>

> ### 단일 책임 원칙
단일 책임 원칙은 **클래스나 모듈을 변경할 이유가 하나뿐이어야 한다는 원칙**이다.
SRP는 책임이라는 개념을 정의하며 적절한 클래스 크기를 제시한다.<br/>

위에서 기술한 매서드가 5개인 클래스는 겉보기에는 작아보이지만 변경할 이유가 2가지가 있다.
  * 소프트웨어 버전 정보를 추적한다.
  * 자바 스윙 컴포넌트를 관리하며 스윙 코드를 변경할 때마다 버전 번호가 달라진다.

따라서 버전 번호 관리/스윙 컴포넌트 관리 2가지 변경할 이유(책임)가 따른다.<br/>

SRP는 객체 지향 설계에서 중요한 개념이며 이해하고 지키기 수월한 개념이다.
하지만 SRP는 클래스 설계자가 가장 무시하는 규칙 중 하나이다.<br/>

소프트웨어를 돌아가게 만드는 활동과 깨끗하게 만드는 활동은 완전히 별개다.<br/>
하지만, 하나의 관심사에만 초점을 맞춰 코드를 작성하는 경우가 대부분이다.<br/>

많은 개발자는 단일 책임 클래스가 많아지면<br/>
클래스를 수 없이 넘나 들어야하기 때문에 큰 그림을 이해하기 어려워진다 말한다.
규모가 어느 수준에 이르는 시스템은 논리가 많고도 복잡하다.
이런 복잡성을 다루려면 체계적인 정리가 필수다.<br/>
그래야 변경을 가할 때 직접 영향이 미치는 컴포넌트만 이해해도 충분하다.

> ### 응집도
클래스는 인스턴스 변수 수가 작아야 한다.<br/>
각 클래스 메서드는 클래스 인스턴스 변수(지역변수)를 하나 이상 사용해야 한다.<br/>
일반적으로 메서드가 변수를 더 많이 사용할 수록 메서드와 클래스는 응집도가 더 높다.<br/>
하지만 가능한한 응집도가 높은 클래스를 지향해야 한다.<br/>
응집도가 높다는 말은 클래스에 속한 메서드와 변수가 <br/>
서로 의존하며 논리적인 단위로 묶인다는 의미기 때문이다.

함수를 작게, 매개변수 목록을 짧게라는 전략을 따르다 보면<br/>
때때로 몇몇 메서드만이 사용하는 인스턴스 변수가 아주 많아진다.<br/>
이는 십중 팔구 새로운 클래스를 쪼개야 한다는 신호다.
